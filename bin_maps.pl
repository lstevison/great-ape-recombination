#! /usr/bin/perl

#calculates mean recombination rate of reduced map files based on user defined block sizes from bed file generated by 'thin_reduced_maps.pl'.
#May 10, 2013
#Modified Apr 2, 2014

$map_file = $ARGV[0];
$bed_file = $ARGV[1];
$output = $ARGV[2];

unless ($#ARGV==2) {
    print STDERR "Program computes mean rec rate in segments along syntenic blocks from $bed_file. Please specify input map file,bed file, and output filename.\n";
    die;
} #end unless

open(MAP, $map_file);
open(BED, $bed_file);
open(OUTPUT, ">$output");

@chr = ();
@start_pos = ();
@end_pos = ();
@bonobo_ori = ();
@chimp_ori = ();
@gorilla_ori = ();

push(@chr, 'zero');
push(@start_pos, 'zero');
push(@end_pos, 'zero');
push(@bonobo_ori, 'zero');
push(@chimp_ori, 'zero');
push(@gorilla_ori, 'zero');

print STDERR "Now reading in bed input file...";

while (<BED>) {
    chomp;
    @input_array = split(/\t/, $_);
    push(@chr, $input_array[0]);
    push(@start_pos, $input_array[1]);
    push(@end_pos, $input_array[2]);
    push(@bonobo_ori, $input_array[4]);
    push(@chimp_ori, $input_array[5]);
    push(@gorilla_ori, $input_array[6]);
} #end while

print STDERR "done.\nNow reading in map file and computing means in each BED segment...";

$map_header = (<MAP>);
$interval=1;
$sum_rate=0;
$sum_distance=0;
$count=0;
$last_interval=0;

while (<MAP>) {
    chomp;
    @map_array = split(/\t/, $_);
REPEAT:
    if ($map_array[0]=~/$chr[$interval]/ && $start_pos[$interval] <= $map_array[1] && $end_pos[$interval] >= $map_array[1]) { #coordinate within interval
	$kb_distance = (abs($map_array[2]-$map_array[1])+1)/1000;
	$rho = $map_array[3]*$kb_distance;
	$sum_distance += $kb_distance;
	$sum_rate += $rho;
	$count++;
	if ($interval==$#chr) {
	    $last_interval=1;
	} #end if
    } elsif ($map_array[0]=~/$chr[$interval+1]/ && $start_pos[$interval+1] <= $map_array[1] && $end_pos[$interval+1] >= $map_array[1]) { #coordinate in next interval
	$mean_rate = $sum_rate/$sum_distance;
#	print STDERR "Now writing summary for interval: $interval\n";
	print OUTPUT "$chr[$interval]\t$start_pos[$interval]\t$end_pos[$interval]\t$mean_rate\t$count\t$sum_distance\t$bonobo_ori[$interval]\t$chimp_ori[$interval]\t$gorilla_ori[$interval]\n";
	$interval++;
	$count=1;
	$sum_distance = (abs($map_array[2]-$map_array[1])+1)/1000;
	$sum_rate = $map_array[3]*$sum_distance;
    } elsif ($last_interval==1) { #reached end of coordinates
	print STDERR "Reached end of coordinates at interval: $interval\n";
	$mean_rate = $sum_rate/$sum_distance;
	print OUTPUT "$chr[$interval]\t$start_pos[$interval]\t$end_pos[$interval]\t$mean_rate\t$count\t$sum_distance\t$bonobo_ori[$interval]\t$chimp_ori[$interval]\t$gorilla_ori[$interval]\n";
	last;
    } elsif ($map_array[0]=~/$chr[$interval+1]/ && $start_pos[$interval+1] < $map_array[1] && $end_pos[$interval+1] < $map_array[1]) { #map interval not in current interval or next!
	$mean_rate = $sum_rate/$sum_distance;
#	print STDERR "Now writing summary for interval: $interval, Rate: $sum_rate, Distance: $sum_distance\n";
	print OUTPUT "$chr[$interval]\t$start_pos[$interval]\t$end_pos[$interval]\t$mean_rate\t$count\t$sum_distance\t$bonobo_ori[$interval]\t$chimp_ori[$interval]\t$gorilla_ori[$interval]\n";
	$interval++;
	$count=0;
	$sum_rate = 0;
	$sum_distance = 0.1;
	print STDERR "Problem site in map at $_\n";
	goto REPEAT;
    } #end elsif

} #end while

print STDERR "done.\n";
